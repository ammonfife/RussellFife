<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra Simple Survivor Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <!-- Phaser Library -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    
    <script>
    // Ultra simple game with no startup screens
    const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
        // Create simple shapes instead of loading images
        this.load.image('background', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==');
    }

    function create() {
        // Add background
        this.add.rectangle(400, 300, 800, 600, 0x000033);
        
        // Add player
        this.player = this.add.rectangle(400, 300, 30, 30, 0x00ff00);
        this.physics.add.existing(this.player);
        this.player.body.setCollideWorldBounds(true);
        
        // Add enemies group
        this.enemies = this.physics.add.group();
        
        // Add experience orbs group
        this.expOrbs = this.physics.add.group();
        
        // Set up collisions
        this.physics.add.overlap(this.player, this.enemies, hitEnemy, null, this);
        this.physics.add.overlap(this.player, this.expOrbs, collectExp, null, this);
        
        // Set up controls
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Game state
        this.score = 0;
        this.health = 100;
        this.level = 1;
        
        // UI
        this.scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#fff' });
        this.healthText = this.add.text(16, 50, 'Health: 100', { fontSize: '24px', fill: '#fff' });
        this.levelText = this.add.text(16, 84, 'Level: 1', { fontSize: '24px', fill: '#fff' });
        this.controlsText = this.add.text(16, 550, 'Controls: Arrow Keys to Move', { fontSize: '18px', fill: '#fff' });
        
        // Spawn enemies every 2 seconds
        this.enemyTimer = this.time.addEvent({
            delay: 2000,
            callback: spawnEnemy,
            callbackScope: this,
            loop: true
        });
    }

    function update() {
        // Player movement
        this.player.body.setVelocity(0);
        
        if (this.cursors.left.isDown) {
            this.player.body.setVelocityX(-160);
        } else if (this.cursors.right.isDown) {
            this.player.body.setVelocityX(160);
        }
        
        if (this.cursors.up.isDown) {
            this.player.body.setVelocityY(-160);
        } else if (this.cursors.down.isDown) {
            this.player.body.setVelocityY(160);
        }
        
        // Auto-attack nearby enemies
        let closestEnemy = null;
        let closestDistance = 150; // Attack range
        
        this.enemies.getChildren().forEach(enemy => {
            const distance = Phaser.Math.Distance.Between(
                this.player.x, this.player.y,
                enemy.x, enemy.y
            );
            
            if (distance < closestDistance) {
                closestEnemy = enemy;
                closestDistance = distance;
            }
            
            // Move enemies toward player
            const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
            const speed = 50 + (this.level * 5); // Enemies get faster with level
            
            enemy.body.setVelocityX(Math.cos(angle) * speed);
            enemy.body.setVelocityY(Math.sin(angle) * speed);
        });
        
        // Attack closest enemy
        if (closestEnemy) {
            if (!this.lastAttackTime || this.time.now - this.lastAttackTime > 1000) {
                this.lastAttackTime = this.time.now;
                
                // Damage enemy
                closestEnemy.health -= 20;
                
                // Visual feedback
                closestEnemy.setFillStyle(0xff0000);
                this.time.delayedCall(100, () => {
                    if (closestEnemy.active) {
                        closestEnemy.setFillStyle(0xff6666);
                    }
                });
                
                // Check if enemy is defeated
                if (closestEnemy.health <= 0) {
                    // Spawn experience orb
                    const expOrb = this.add.circle(closestEnemy.x, closestEnemy.y, 10, 0x00ffff);
                    this.physics.add.existing(expOrb);
                    this.expOrbs.add(expOrb);
                    expOrb.value = 10;
                    
                    // Destroy enemy
                    closestEnemy.destroy();
                    
                    // Update score
                    this.score += 10;
                    this.scoreText.setText('Score: ' + this.score);
                }
            }
        }
        
        // Move experience orbs toward player when close
        this.expOrbs.getChildren().forEach(orb => {
            const distance = Phaser.Math.Distance.Between(
                this.player.x, this.player.y,
                orb.x, orb.y
            );
            
            if (distance < 100) {
                const angle = Phaser.Math.Angle.Between(orb.x, orb.y, this.player.x, this.player.y);
                const speed = 100;
                
                orb.body.setVelocityX(Math.cos(angle) * speed);
                orb.body.setVelocityY(Math.sin(angle) * speed);
            }
        });
    }

    function spawnEnemy() {
        // Determine spawn position (outside screen)
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -50 : 850;
            y = Phaser.Math.Between(0, 600);
        } else {
            x = Phaser.Math.Between(0, 800);
            y = Math.random() < 0.5 ? -50 : 650;
        }
        
        // Create enemy
        const enemy = this.add.rectangle(x, y, 25, 25, 0xff6666);
        this.physics.add.existing(enemy);
        this.enemies.add(enemy);
        enemy.health = 40 + (this.level * 10); // Enemies get tougher with level
    }

    function hitEnemy(player, enemy) {
        // Player takes damage
        this.health -= 5;
        this.healthText.setText('Health: ' + this.health);
        
        // Visual feedback
        player.setFillStyle(0xff0000);
        this.time.delayedCall(100, () => {
            player.setFillStyle(0x00ff00);
        });
        
        // Check game over
        if (this.health <= 0) {
            this.physics.pause();
            player.setFillStyle(0xff0000);
            
            const gameOver = this.add.text(400, 300, 'GAME OVER', {
                fontSize: '64px',
                fill: '#fff'
            }).setOrigin(0.5);
            
            // Restart button
            const restartButton = this.add.text(400, 400, 'Restart', {
                fontSize: '32px',
                fill: '#fff',
                backgroundColor: '#000',
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive();
            
            restartButton.on('pointerdown', () => {
                this.scene.restart();
            });
        }
    }

    function collectExp(player, expOrb) {
        // Collect experience
        this.score += expOrb.value;
        this.scoreText.setText('Score: ' + this.score);
        
        // Check level up
        if (this.score >= this.level * 100) {
            this.level++;
            this.levelText.setText('Level: ' + this.level);
            
            // Visual feedback
            player.setFillStyle(0x00ffff);
            this.time.delayedCall(300, () => {
                player.setFillStyle(0x00ff00);
            });
        }
        
        // Destroy orb
        expOrb.destroy();
    }
    </script>
</body>
</html>
